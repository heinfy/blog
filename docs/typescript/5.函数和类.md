
## 函数

### 函数的类型签名

```ts
// 方式一
function foo(name: string): number {
  return name.length;
}

// 方式二
type FuncFoo = (name: string, age: number) => number;


const foo: FuncFoo = name => {
  return name.length;
}

// 方式三
interface FuncFooStruct {
  (name: string, age: number): number;
}

const foo: FuncFooStruct = (name, age) => {
  console.log(age);
  return name.length;
};

```

### 重载

```ts
function func(foo: number, bar: true): string;
function func(foo: number, bar?: false): number;
function func(foo: number, bar?: boolean): string | number {
  if (bar) {
    return String(foo);
  } else {
    return foo * 599;
  }
}

const res1 = func(599); // number
const res2 = func(599, true); // string
const res3 = func(599, false); // number
```


- `function func(foo: number, bar: true): string`，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。
- `function func(foo: number, bar?: false): number`，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。
- `function func(foo: number, bar?: boolean): string | number`，函数的实现签名，会包含重载签名的所有可能情况。

### 异步函数、Generator 函数等类型签名

```ts
async function asyncFunc(): Promise<void> {}

function* genFunc(): Iterable<void> {}

async function* asyncGenFunc(): AsyncIterable<void> {}
```

## Class

```ts
class Foo {
  prop: string;

  constructor(inputProp: string) {
    this.prop = inputProp;
  }

  print(addon: string): void {
    console.log(`${this.prop} and ${addon}`)
  }

  get propA(): string {
    return `${this.prop}+A`;
  }

  set propA(value: string) {
    this.prop = `${value}+A`
  }
}
```

### 修饰符

```ts
class Foo {
  private prop: string;

  constructor(inputProp: string) {
    this.prop = inputProp;
  }

  static staticHandler() { }

  protected print(addon: string): void {
    console.log(`${this.prop} and ${addon}`)
  }

  public get propA(): string {
    return `${this.prop}+A`;
  }

  public set propA(value: string) {
    this.propA = `${value}+A`
  }
}
```

- `static`：标识一个成员为静态成员。
- `public`：此类成员在类、类的实例、子类中都能被访问。
- `private`：此类成员仅能在类的内部被访问。
- `protected`：此类成员仅能在类与子类中被访问。

### 继承、实现、抽象类

```ts
class Base {
  print() { }
}

class Derived extends Base {
  print() {
    super.print()
    // ...
  }
}


class Derived2 extends Base {
  // override 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义
  override print() {
    // ...
  }
}
```

抽象类使用 abstract 关键字声明：

```ts
abstract class AbsFoo {
  abstract absProp: string;
  abstract get absGetter(): string;
  abstract absMethod(name: string): string;
}

class Foo implements AbsFoo {
  absProp: string = 'linbudu';

  get absGetter() {
    return 'linbudu';
  }

  absMethod(name: string) {
    return name;
  }
}
```