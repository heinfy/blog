将 unknown 类型断言到一个具体的类型：

```ts
let unknownVar: unknown;

(unknownVar as { foo: () => {} }).foo();
```

as 到 any 跳过所有的类型检查：

```ts
const str: string = "Tom";

(str as any).func().foo().prop;
```

联合类型中断言一个具体的分支：

```ts
function foo(union: string | number) {
  if ((union as string).includes("TOM")) { }

  if ((union as number).toFixed() === '12') { }
}
```

## 双重断言

```ts
const str: string = "linbudu";

// 从 X 类型 到 Y 类型的断言可能是错误的，blabla
(str as { handler: () => {} }).handler()
```

```ts
const str: string = "linbudu";

(str as unknown as { handler: () => {} }).handler();

// 使用尖括号断言
(<{ handler: () => {} }>(<unknown>str)).handler();
```

## 非空断言

```ts
foo.func!().prop!.toFixed();
```

## 类型守卫

```ts
// 类型控制流分析做不到跨函数上下文来进行类型的信息收集
function isString(input: unknown): input is string {
  return typeof input === 'string';
}

function foo(input: string | number) {
  if (isString(input)) {
    input.replace('linbudu', 'linbudu599');
  }
  if (typeof input === 'number') {
  }
  // ...
}
```

