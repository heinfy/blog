# 编程题

## 求数组中俩项和为一个字

源数组 `let arr = [3, 1, 5, 7, 3, 2, 4]`，写一个函数，返回值为`[[0,4], [1,2], [5,6]]`，这个数组中所有两项之和为 6 的下标数组

```js
// func 1
function getArray1(arr) {
  let result = [],
    len = arr.length;
  for (let i = 0; i < len; i++) {
    let item = arr[i];
    for (let j = i + 1; j < len; j++) {
      if (item + arr[j] === 6) {
        result.push([i, j]);
      }
    }
  }
  return result;
}

// func 2
function getArray2(arr) {
  let result = [];
  let len = arr.length;
  for (let i = 0; i < len; i++) {
    let j = arr.indexOf(6 - arr[i], i + 1);
    if (j > i) result.push([i, j]);
  }
  return result;
}

// func 3
function getArray3(arr) {
  let result = [];
  let len = arr.length;
  for (let i = 0; i < len; i++) {
    let j = arr.lastIndexOf(6 - arr[i]);
    if (j > i) result.push([i, j]);
  }
  return result;
}
```

## 函数 arguments

```js
// 情景一：
// 情景二：加上"use strict"
function foo(x, y, z) {
  console.log(arguments.length);
  console.log(arguments[0]);
  arguments[0] = 10;
  console.log(x);
  arguments[z] = 100;
  console.log(z);
}
foo(1, 2);
console.log(foo.length); // 3
console.log(foo.name); // foo

// 情景一： 2 1 10 undefined 3 foo
// 情景二：加上"use strict"  2 1 1 undefined 3 foo

// use strict对arguments做了以下限定
// 不允许对arguments赋值。禁止使用arguments.callee。arguments不再追踪参数的变化
```

## async 执行机制

```js
async function async1() {
  console.log('1');
  await async2();
  console.log('2');
}
async function async2() {
  console.log('3');
}

console.log('4');

setTimeout(function () {
  // 推到宏队列
  console.log('5');
}, 0);

async1(); // 调用方法，执行函数

new Promise(function (resolve) {
  console.log('6');
  resolve();
}).then(function () {
  console.log('7');
});
console.log('8');
// 4 1 3 6 8 2 7 5
```

1. 执行全局代码，输出 `4`。
2. 调用 `async1()` 函数，输出 `1`。
3. 在 `async1()` 函数中调用 `async2()` 函数，输出 `3`。
4. 因为 `async2()` 函数没有使用 `await` 关键字，它会立即返回一个 resolved promise 对象，`async1()` 函数中的 `await` 表达式得到了这个 resolved promise 对象，然后执行到下一行代码，执行了微任务队列中的所有任务，因此现在输出 `6`。
5. 输出 `8`。
6. `async1()` 函数执行完成，执行了微任务队列中的所有任务，输出 `2`。
7. 在主线程空闲时，执行 promise 的 `then()` 回调函数，输出 `7`。

在步骤 4 中，我们执行了以下操作：

1. `async2()` 函数在调用时会立即输出 `3`。
2. 因为 `async2()` 函数没有使用 `await` 关键字，它会立即返回一个 resolved promise 对象。
3. `async1()` 函数中的 `await async2()` 表达式得到了这个 resolved promise 对象，因此 `async1()` 函数中的执行暂停，直到这个 resolved promise 对象变成 settled 状态（即 resolved 或 rejected）。
4. 在这个例子中，resolved promise 对象的状态已经是 resolved，因此它会立即执行队列中的微任务（也就是步骤 5 中创建的 promise 的 executor 函数）。
5. 执行完微任务队列中的所有任务之后，`async1()` 函数才会继续执行到下一行代码，输出 `2`。

总之，步骤 4 中的关键点是，因为 `async2()` 函数立即返回一个 resolved promise 对象，它不会阻塞 `async1()` 函数的执行，而是将控制权交回给 `async1()` 函数，让它继续执行，直到下一个 `await` 表达式或函数结束。在这个例子中，`async1()` 函数在得到 resolved promise 对象之后，立即执行了队列中的微任务，然后才输出 `2`。

## 001

东东从京京那里了解到有一个无限长的数字序列: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, ...(数字 k 在该序列中正好出现 k 次)。东东想知道这个数字序列的第 n 项是多少,你能帮帮他么 ？

```js
/*
  第一项：1 —— 占1个序列
  第二项：2 2 ——占2个序列
  第三项：3 3 3  ——占3个序列
  ···
  第k项： k1 k2 k3 ···  kk ——占k个序列
  求第169个序列所在第几项？
  故求第n个序列就是求第k项的前k项和，由是等差数列，n=k(k+1)/2,
  因为第k项不管是k几序列，算出的都是小于或等于k的，故向上取整。

  代码实现：
*/

// 整体排序
function getItem01(num) {
  return Math.ceil((Math.sqrt(1 + 8 * num) - 1) / 2);
}
console.log(getItem01(169)); // 18

// 顺序算法
function getItem02(num) {
  for (let i = 1; i < num; i++) {
    if ((i * (i - 1)) / 2 <= num && (i * (i + 1)) / 2 >= num) {
      return i;
    }
  }
}
console.log(getItem02(169)); // 18
```
