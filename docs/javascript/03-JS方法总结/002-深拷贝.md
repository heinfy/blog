# 拷贝

## 浅拷贝

- `Object.create(obj)`
- `Object.assign({} , obj)`
- `[ ].concat(arr)`
- 数组解构

## 深拷贝

### 方法 1

```js
function deepCopy(obj) {
  // 如果是基本类型或函数直接返回
  if (typeof obj !== 'object' || obj === null || typeof obj === 'function') {
    return obj;
  }

  // 根据对象的类型创建一个新的空对象或数组
  const copy = Array.isArray(obj) ? [] : {};

  // 遍历原对象的属性
  for (let key in obj) {
    // 检查是否为自身属性而非原型链上的属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用deepCopy，以实现深拷贝
      copy[key] = deepCopy(obj[key]);
    }
  }

  return copy;
}
```

### 方法 2

```js
function deepClone(obj) {
  if (typeof obj !== 'object' || obj === null) {
    // 值类型和 null 直接返回
    return obj;
  }

  let clone = null;
  const type = Object.prototype.toString.call(obj);
  switch (type) {
    case '[object Array]':
      // 数组类型
      clone = [];
      for (let i = 0; i < obj.length; i++) {
        clone.push(deepClone(obj[i]));
      }
      break;
    case '[object Date]':
      // 日期类型
      clone = new Date(obj.getTime());
      break;
    case '[object RegExp]':
      // 正则表达式类型
      clone = new RegExp(obj);
      break;
    case '[object Function]':
      // 函数类型
      clone = obj;
      break;
    default:
      // 对象类型（包括普通对象和其他内置对象）
      clone = {};
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          clone[key] = deepClone(obj[key]);
        }
      }
      break;
  }

  return clone;
}
```

## 深拷贝函数方法

```js
function cloneFunction(func) {
  return eval('(' + func.toString() + ')');
}
// 使用示例
const func1 = function () {
  console.log('Hello, world!');
};
const func2 = cloneFunction(func1);
console.log(func1 === func2); // false
```
