# 拷贝

## 深拷贝函数 1

```js
function deepCopy(obj) {
  // 如果是基本类型或函数直接返回
  if (typeof obj !== 'object' || obj === null || typeof obj === 'function') {
    return obj;
  }

  // 根据类型创建新对象
  const newObj = Array.isArray(obj) ? [] : {};

  // 递归复制对象属性
  for (let key in obj) {
    newObj[key] = deepCopy(obj[key]);
  }

  return newObj;
}
```

## 深拷贝函数 2

```js
function deepClone(obj) {
  if (typeof obj !== 'object' || obj === null) {
    // 值类型和 null 直接返回
    return obj;
  }

  let clone = null;
  const type = Object.prototype.toString.call(obj);
  switch (type) {
    case '[object Array]':
      // 数组类型
      clone = [];
      for (let i = 0; i < obj.length; i++) {
        clone.push(deepClone(obj[i]));
      }
      break;
    case '[object Date]':
      // 日期类型
      clone = new Date(obj.getTime());
      break;
    case '[object RegExp]':
      // 正则表达式类型
      clone = new RegExp(obj);
      break;
    case '[object Function]':
      // 函数类型
      clone = obj;
      break;
    default:
      // 对象类型（包括普通对象和其他内置对象）
      clone = {};
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          clone[key] = deepClone(obj[key]);
        }
      }
      break;
  }

  return clone;
}
```

## 深拷贝函数方法

```js
function cloneFunction(func) {
  return eval('(' + func.toString() + ')');
}
// 使用示例
const func1 = function () {
  console.log('Hello, world!');
};
const func2 = cloneFunction(func1);
console.log(func1 === func2); // false
```
