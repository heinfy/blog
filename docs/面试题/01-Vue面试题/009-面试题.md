# vue 面试题

## Vue2.0 v-for 中 :key 到底有什么用？

需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节
点。所以一句话，**key 的作用主要是为了高效的更新虚拟 DOM**。

## `v-for` 和 `v-if` 使用问题

v-for 的优先级比 v-if 的优先级高，在遍历每一条 item 后，会执行 v-if，会造成不必要的计算，影响性能。

解决方法：通过使用 computed 属性，来筛选出符合条件项，然后再使用 v-for 遍历

## 实例属性 data 为什么是一个 function

组件是一个可复用的实例，当你引用一个组件的时候，组件里的 data 是一个普通的对象，所有用到这个组件的都
引用的同一个 data，就会造成数据污染。

将 data 封装成函数后，在实例化组件的时候，我们只是调用了 data 函数生成的数据副本，避免了数据污染。

## 在哪个生命周期发起 ajax

不考虑服务器端渲染：在 created 和 mounted 都可以，created 周期内，数据已经加载完毕，mounted 周期内
，vdom 已经被挂载到实例上，此时 ajax，如果只做`{{}}`渲染，俩个周期都可以，如果发生 dom 更新，在
mounted 比较合适。

## hash 和 history 模式的区别

hash 模式：在浏览器 url 中提现为#，#以及之后的内容用`window.location.hash`读取。特点：hash 虽然在
URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。

hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 [http://www.xxx.com](http://www.xxx.com/)，
因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

history 模式：history 采用 HTML5 的新特性；且提供了两个新方法：pushState（），replaceState（）可以对
浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更。 history 模式下，前端的 URL 必须和实际
向后端发起请求的 URL 一致，如 `http://www.xxx.com/items/id`。后端如果缺少对 /items/id 的路由处理，将
返回 404 错误。

## 计算属性怎么理解

在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量
采取计算属性的方式。

好处：

① 使得数据处理结构清晰；

② 依赖于数据，数据更新，处理结果自动更新；

③ 计算属性内部 this 指向 vm 实例；

④ 在 template 调用时，直接写计算属性名即可；

⑤ 常用的是 getter 方法，获取数据，也可以使用 set 方法改变数据；

⑥ 相较于 methods，不管依赖的数据变不变，methods 都会重新计算，但是依赖数据不变的时候 computed 从缓存
中获取，不会重新计算。

## `v-on`可以监听多个方法

```vue
<input type="text" v-on="{ input: onInput, focus: onFocus, blur: onBlur }" />
```

## vue2 的 Object.defineProperty 和 vue3 的 Proxy 有什么区别？

Vue.js 2.x 使用了 `Object.defineProperty` 来实现数据的双向绑定。这意味着当你修改数据时，Vue.js 会使
用 `Object.defineProperty` 来拦截对数据的访问和修改，从而触发视图的更新。这种方法在 Vue 2.x 中被称为
响应式系统。

Vue.js 3.x 引入了一个新的响应式系统，使用了 JavaScript 的 Proxy 对象。与 `Object.defineProperty` 不
同，Proxy 提供了一种更强大和灵活的方式来拦截和监听对象上的操作。使用 Proxy，你可以监听对象的读取、写
入、删除等操作，而不仅仅是属性的访问和修改。

这里是两者之间的主要区别：

1. **功能和灵活性：**
   - **`Object.defineProperty`（Vue 2.x）：** 它只能监听属性的读取和修改，无法监听属性的添加和删除。
     而且它需要遍历对象的所有属性，逐一进行处理，性能较差。
   - **`Proxy`（Vue 3.x）：** 它提供了更灵活的拦截器，可以监听对象的读取、写入、删除等操作，不仅限于
     属性的访问和修改。而且由于 Proxy 是基于对象整体的，性能上相对更好，因为不需要遍历对象的所有属性
     。
2. **性能：**
   - **`Object.defineProperty`（Vue 2.x）：** 对于大型对象，遍历所有属性并使用
     `Object.defineProperty` 进行处理可能会导致性能问题。
   - **`Proxy`（Vue 3.x）：** Proxy 的性能通常比 `Object.defineProperty` 更好，尤其是在处理大型对象
     时，因为 Proxy 是针对整个对象的操作，不需要遍历属性。
3. **新增和删除属性的处理：**
   - **`Object.defineProperty`（Vue 2.x）：** 无法监听属性的添加和删除，因此需要使用特殊的方法（例如
     `$set`）来添加响应式属性。
   - **`Proxy`（Vue 3.x）：** 可以监听属性的添加和删除，不需要特殊的方法，使得代码更加简洁和直观。

总之，Vue.js 3.x 中的 Proxy 提供了更灵活、性能更好、语法更简洁的响应式系统，相比 Vue 2.x 中的
`Object.defineProperty`，它具有更多的优势。
