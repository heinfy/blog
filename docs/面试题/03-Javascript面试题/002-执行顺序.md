## async 执行机制

```js
async function async1() {
  console.log('1');
  await async2();
  console.log('2');
}
async function async2() {
  console.log('3');
}

console.log('4');

setTimeout(function () {
  // 推到宏队列
  console.log('5');
}, 0);

async1(); // 调用方法，执行函数

new Promise(function (resolve) {
  console.log('6');
  resolve();
}).then(function () {
  console.log('7');
});
console.log('8');
// 4 1 3 6 8 2 7 5
```

1. 执行全局代码，输出 `4`。
2. 调用 `async1()` 函数，输出 `1`。
3. 在 `async1()` 函数中调用 `async2()` 函数，输出 `3`。
4. 因为 `async2()` 函数没有使用 `await` 关键字，它会立即返回一个 resolved promise 对象，`async1()`
   函数中的 `await` 表达式得到了这个 resolved promise 对象，然后执行到下一行代码，执行了微任务队列中
   的所有任务，因此现在输出 `6`。
5. 输出 `8`。
6. `async1()` 函数执行完成，执行了微任务队列中的所有任务，输出 `2`。
7. 在主线程空闲时，执行 promise 的 `then()` 回调函数，输出 `7`。

在步骤 4 中，我们执行了以下操作：

1. `async2()` 函数在调用时会立即输出 `3`。
2. 因为 `async2()` 函数没有使用 `await` 关键字，它会立即返回一个 resolved promise 对象。
3. `async1()` 函数中的 `await async2()` 表达式得到了这个 resolved promise 对象，因此 `async1()` 函数
   中的执行暂停，直到这个 resolved promise 对象变成 settled 状态（即 resolved 或 rejected）。
4. 在这个例子中，resolved promise 对象的状态已经是 resolved，因此它会立即执行队列中的微任务（也就是
   步骤 5 中创建的 promise 的 executor 函数）。
5. 执行完微任务队列中的所有任务之后，`async1()` 函数才会继续执行到下一行代码，输出 `2`。

总之，步骤 4 中的关键点是，因为 `async2()` 函数立即返回一个 resolved promise 对象，它不会阻塞
`async1()` 函数的执行，而是将控制权交回给 `async1()` 函数，让它继续执行，直到下一个 `await` 表达式或
函数结束。在这个例子中，`async1()` 函数在得到 resolved promise 对象之后，立即执行了队列中的微任务，
然后才输出 `2`。

## 函数执行顺序

```js
// 构造函数
function Foo() {
  // 赋值给全局变量 getName 的匿名函数
  // 如果 Foo 函数没有执行，下面这个 getName 的赋值行为是不进行的
  getName = function () {
    console.log(1);
  };
  console.log(this);
  return this;
}

// 函数Foo上的静态方法，一个函数对象上的方法、属性
Foo.getName = function () {
  console.log(2);
};

// 扩展函数原型上的方法
// 调用 new Foo().getName()
Foo.prototype.getName = function () {
  console.log(3);
};

// 给全局变量赋值一个匿名函数
var getNanme = function () {
  console.log(4);
};

// 函数声明
function getName() {
  console.log(5);
}

// 注意 new 函数时，this指向函数生成的实例
Foo.getName(); // 2 执行静态方法
getName(); // 5 -> 4 this => window 函数表达式 和 函数声明 变量提升 先时函数声明的5，后被函数表达式赋给4
Foo().getName(); // 5 => 1 Foo()调用，将释放内部全局函数，此时，z覆盖 之前的函数声明，然后执行被释放出来的全局函数表达式 此时 this 指向 window
getName(); // 1 同上，这是最后的函数表达式
new Foo.getName(); // 2 执行静态方法
new Foo().getName(); // 3 执行原型上的方法 此时 this 指向 foo
new new Foo().getName(); // 3 执行原型上的方法 此时 this 指向 foo
```
