## async 执行机制

```js
async function async1() {
  console.log('1');
  await async2();
  console.log('2');
}
async function async2() {
  console.log('3');
}

console.log('4');

setTimeout(function () {
  // 推到宏队列
  console.log('5');
}, 0);

async1(); // 调用方法，执行函数

new Promise(function (resolve) {
  console.log('6');
  resolve();
}).then(function () {
  console.log('7');
});
console.log('8');
// 4 1 3 6 8 2 7 5
```

1. 执行全局代码，输出 `4`。
2. 调用 `async1()` 函数，输出 `1`。
3. 在 `async1()` 函数中调用 `async2()` 函数，输出 `3`。
4. 因为 `async2()` 函数没有使用 `await` 关键字，它会立即返回一个 resolved promise 对象，`async1()`
   函数中的 `await` 表达式得到了这个 resolved promise 对象，然后执行到下一行代码，执行了微任务队列中
   的所有任务，因此现在输出 `6`。
5. 输出 `8`。
6. `async1()` 函数执行完成，执行了微任务队列中的所有任务，输出 `2`。
7. 在主线程空闲时，执行 promise 的 `then()` 回调函数，输出 `7`。

在步骤 4 中，我们执行了以下操作：

1. `async2()` 函数在调用时会立即输出 `3`。
2. 因为 `async2()` 函数没有使用 `await` 关键字，它会立即返回一个 resolved promise 对象。
3. `async1()` 函数中的 `await async2()` 表达式得到了这个 resolved promise 对象，因此 `async1()` 函数
   中的执行暂停，直到这个 resolved promise 对象变成 settled 状态（即 resolved 或 rejected）。
4. 在这个例子中，resolved promise 对象的状态已经是 resolved，因此它会立即执行队列中的微任务（也就是
   步骤 5 中创建的 promise 的 executor 函数）。
5. 执行完微任务队列中的所有任务之后，`async1()` 函数才会继续执行到下一行代码，输出 `2`。

总之，步骤 4 中的关键点是，因为 `async2()` 函数立即返回一个 resolved promise 对象，它不会阻塞
`async1()` 函数的执行，而是将控制权交回给 `async1()` 函数，让它继续执行，直到下一个 `await` 表达式或
函数结束。在这个例子中，`async1()` 函数在得到 resolved promise 对象之后，立即执行了队列中的微任务，
然后才输出 `2`。
