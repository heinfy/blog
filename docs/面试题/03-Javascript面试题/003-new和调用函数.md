# new 函数和调用函数

- [JavaScript:new 一个函数和直接调用函数的区别分析](https://www.jb51.net/article/39653.htm)

## new 函数和调用函数的区别

```js
function Test() {
  console.log(this);
  this.name = 'Test';
  return function () {
    return true;
  };
}
var test = new Test(); // this => Test {}
console.log(test); // ƒ () {return true}
var test1 = Test(); // this => window
console.log(test1); // ƒ () {return true}
```

上面这个函数，使用 new 执行以后，并没有返回一个实例对象，而是返回了 return 之后的函数；直接调用函数
，不会改变 `this` 的指向，如果是返回一个简单数据类型呢：

```js
function Test() {
  console.log(this);
  this.name = 'Test';
  return '这是一个字符串';
}
var test = new Test(); // this => Test{}
console.log(test); // Test {name: "Test"}
var test1 = Test(); // this => window
console.log(test1); // ƒ () {return true}
```

这时会返回 `Test` 的实例对象。

通过上面两段代码，我们可以得出一个猜测，如果函数返回值为简单数据类型时，new 函数将会返回一个该函数的
实例对象，而如果函数返回一个引用类型，则 new 函数与直接调用函数产生的结果等同。

_通常，为了区分普通函数和构造函数，构造函数的首字母要大写。_

## new 一个对象的过程

```js
function Father(firstName) {
  this.firstName = firstName;
}
var son = Father('李');
```

1. 创建一个新对象`son`
2. 新对象会被执行`[[prototype]]`连接： `son.__proto__ = Father.prototype`
3. 新对象和函数调用的`this`会绑定起来： `Father.call(son, '李')`
4. 执行构造函数中的代码：`this.firstName = firstName`
5. 如果函数没有返回值，那么就会自动返回这个新对象。 `return this`

## this 指向

- 默认绑定

```javascript
function girl1() {
  console.log(this); // window
}
girl1();
```

- 隐式绑定

```javascript
var girl2 = {
  name: '小红',
  age: 18,
  detail: function () {
    console.log(this); // 指向 girl2 对象
    console.log('姓名： ', this.name);
    console.log('年级： ', this.age);
  }
};
girl2.detail();
```

- 硬绑定

```javascript
var girlName = {
  name: '小红',
  sanName: function () {
    console.log(this); // 指向 call，apply 的对象
    console.log('我的女孩：', this.name);
  }
};
var girl3 = {
  name: '小白'
};
var girl4 = {
  name: '小黄'
};
girlName.sanName.call(girl3);
girlName.sanName.call(girl4);
```

- 构造函数绑定

```javascript
function Lover(name) {
  this.name = name;
  this.sayName = function () {
    console.log(this); // 指向调用构造函数生成的实例
    console.log('我的女孩：', this.name);
  };
}
var name = '小白';
var xiaoHong = new Lover('小红');
xiaoHong.sayName();
```

## 函数 arguments

```js
// 情景一：
// 情景二：加上"use strict"
function foo(x, y, z) {
  console.log(arguments.length);
  console.log(arguments[0]);
  arguments[0] = 10;
  console.log(x);
  arguments[z] = 100;
  console.log(z);
}
foo(1, 2);
console.log(foo.length); // 3
console.log(foo.name); // foo

// 情景一： 2 1 10 undefined 3 foo
// 情景二：加上"use strict"  2 1 1 undefined 3 foo

// use strict对arguments做了以下限定
// 不允许对arguments赋值。禁止使用arguments.callee。arguments不再追踪参数的变化
```

## 打印问题

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b); // function b() { ... }
})();
```

这是因为代码中定义了一个自执行的函数，这个函数的名称是 `b`。在函数内部，有一行代码尝试将 `b` 变量赋
值为 `20`，但这个赋值语句会失败。

原因是，函数名 `b` 在自执行函数内部被重新定义为函数本身，这会导致 `b` 成为一个指向该函数的引用。因此
，尝试将 `b` 变量赋值为 `20` 实际上是尝试修改函数的引用，而不是创建一个新的局部变量 `b`。

所以，当 `console.log(b)` 被执行时，它实际上在打印函数对象本身，而不是变量 `b` 的值。因此，输出的内
容是函数对象的字符串表示：`ƒ b() { b = 20; console.log(b); }`。

这段代码中涉及了函数作用域和变量提升的概念。在函数内部，函数名 `b` 会覆盖外部作用域的变量 `b`，并且
在函数内部，`b` 被定义为函数本身。这是 JavaScript 的特性之一，因此要小心不要在函数内部重新定义已存在
于外部作用域的变量，以避免混淆和错误。
